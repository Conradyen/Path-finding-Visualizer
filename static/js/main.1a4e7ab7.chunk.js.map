{"version":3,"sources":["components/GraphNode.js","algorithms/utils.js","algorithms/dijkstra.js","Datastructer/heap.js","algorithms/aStar.js","Datastructer/queue.js","algorithms/greedyBFS.js","algorithms/dfs.js","components/Controller.js","components/Graph.js","components/label.js","App.js","serviceWorker.js","index.js"],"names":["GraphNode","key","col","isFinish","isStart","isWall","onMouseDown","mouseIsPressed","onMouseEnter","onMouseUp","onMouseOut","row","extraClassName","id","className","sortNodes","unvisitedNodes","sort","nodeA","nodeB","distance","updateUnvisitedNeighbors","node","grid","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","previousNode","neighbors","push","length","filter","isVisited","getNodesInShortestPathOrder","finishNode","nodesInShortestPathOrder","currentNode","unshift","dijkstra","startNode","visitedNodesInOrder","nodes","getAllNodes","closestNode","shift","Infinity","minHeap","scoreFunction","this","content","aStar","cost","minheap","isEmpty","pop","newCost","Math","abs","queue","items","greedyBFS","q","enqueue","dequeue","visited","dfs","dfsHelper","prototype","element","percolateUp","result","end","percolateDown","size","n","score","parentN","floor","parent","elemScore","child2N","child1N","swap","child1","child1Score","child2","clear","useStyles","makeStyles","formControl","minWidth","margin","Controller","useAlgo","handelAlgoChange","handelStartBtnClick","handleResetButtonClick","handleClearWall","classes","Paper","elevation","Grid","container","spacing","alignItems","justify","item","FormControl","InputLabel","Select","labelId","value","onChange","MenuItem","Button","variant","color","onClick","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","initGrid","currentRow","getNewNode","getNewGridWithWallToggled","newGrid","slice","newNode","Graph","useState","setGrid","mouseDown","setMouse","startMove","setstartMove","endMove","setEndMove","startROW","setstartROW","startCOL","setstartCOL","endROW","setendROW","endCOL","setendCOL","setAlgo","algoDone","setalgoDone","getNewGridWithStartMoved","getNewGridWithEndMoved","resetAllDistance","i","j","directShowShortestPath","document","getElementById","handelSPafterAlgocomplete","resetAllClassName","directShowVisitedNode","animateShortestPath","setTimeout","Fragment","map","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseOut","e","target","animateVisitedNode","Label","App","Boolean","window","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.1a4e7ab7.chunk.js","sourcesContent":["import React from \"react\";\nimport \"./node.css\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { faPlay, faMapMarkerAlt } from \"@fortawesome/free-solid-svg-icons\";\n\nexport default function GraphNode({\n  key,\n  col,\n  isFinish,\n  isStart,\n  isWall,\n  mouseIsPressed,\n  onMouseDown,\n  onMouseEnter,\n  onMouseUp,\n  onMouseOut,\n  row,\n}) {\n  const extraClassName = isFinish\n    ? \"node-finish\"\n    : isStart\n    ? \"node-start\"\n    : isWall\n    ? \"node-wall\"\n    : \"\";\n  return (\n    <div\n      id={`node-${row}-${col}`}\n      className={`node ${extraClassName}`}\n      onMouseDown={() => onMouseDown(row, col)}\n      onMouseEnter={() => onMouseEnter(row, col)}\n      onMouseUp={() => onMouseUp()}\n      onMouseOut={() => onMouseOut(row, col)}\n    ></div>\n  );\n}\n","export function sortNodes(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nexport function sortNodesAstar(unvisitedNodes, endNode) {\n  unvisitedNodes.sort(\n    (nodeA, nodeB) =>\n      nodeA.distance +\n      euclideanDistance(nodeA, endNode) -\n      (nodeB.distance + euclideanDistance(nodeB, endNode))\n  );\n}\n\nexport function NodeCompareElement(Node) {\n  return Node.distance;\n}\n\nexport function updateUnvisitedNeighbors(node, grid, distance) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\n\nexport function getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\n}\n\nexport function getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\n//calculate distance between start and end.\nexport function euclideanDistance(startNode, endNode) {\n  const col_d = Math.abs(endNode.col - startNode.col);\n  const row_d = Math.abs(endNode.row - startNode.row);\n  return col_d + row_d;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","import { sortNodes, updateUnvisitedNeighbors, getAllNodes } from \"./utils\";\n\n// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (!!unvisitedNodes.length) {\n    sortNodes(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid, 0);\n  }\n}\n","export function minHeap(scoreFunction) {\n  this.content = [];\n  this.scoreFunction = scoreFunction;\n}\n\nminHeap.prototype = {\n  isEmpty: function () {\n    return this.content.length === 0;\n  },\n  push: function (element) {\n    this.content.push(element);\n    this.percolateUp(this.content.length - 1);\n  },\n\n  pop: function () {\n    var result = this.content[0];\n    var end = this.content.pop();\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.percolateDown(0);\n    }\n    return result;\n  },\n\n  size: function () {\n    return this.content.length;\n  },\n\n  percolateUp: function (n) {\n    var element = this.content[n],\n      score = this.scoreFunction(element);\n    while (n > 0) {\n      var parentN = Math.floor((n + 1) / 2) - 1,\n        parent = this.content[parentN];\n      if (score > this.scoreFunction(parent)) break;\n      this.content[parentN] = element;\n      this.content[n] = parent;\n      n = parentN;\n    }\n  },\n\n  percolateDown: function (n) {\n    var length = this.content.length,\n      element = this.content[n],\n      elemScore = this.scoreFunction(element);\n\n    while (true) {\n      var child2N = (n + 1) * 2,\n        child1N = child2N - 1;\n      var swap = null;\n\n      if (child1N < length) {\n        var child1 = this.content[child1N],\n          child1Score = this.scoreFunction(child1);\n        if (child1Score < elemScore) swap = child1N;\n      }\n      if (child2N < length) {\n        var child2 = this.content[child2N],\n          child2Score = this.scoreFunction(child2);\n        if (child2Score < (swap == null ? elemScore : child1Score))\n          swap = child2N;\n      }\n\n      if (swap == null) break;\n      this.content[n] = this.content[swap];\n      this.content[swap] = element;\n      n = swap;\n    }\n  },\n};\n","import { getUnvisitedNeighbors } from \"./utils\";\nimport { minHeap } from \"../Datastructer/heap\";\n\nexport function aStar(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  startNode.cost = 0;\n  visitedNodesInOrder.push(startNode);\n  //const unvisitedNodes = getAllNodes(grid);\n  var minheap = new minHeap((node) => {\n    return node.cost;\n  });\n  minheap.push(startNode);\n  while (!minheap.isEmpty()) {\n    // sortNodesAstar(unvisitedNodes, finishNode);\n    const closestNode = minheap.pop();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    const unvisitedNeighbors = getUnvisitedNeighbors(closestNode, grid);\n    for (const neighbor of unvisitedNeighbors) {\n      if (closestNode.distance + 1 < neighbor.distance) {\n        neighbor.distance = closestNode.distance + 1;\n        neighbor.previousNode = closestNode;\n        visitedNodesInOrder.push(closestNode);\n      }\n      var newCost =\n        closestNode.distance +\n        Math.abs(finishNode.col - neighbor.col) +\n        Math.abs(finishNode.row - neighbor.row);\n\n      if (newCost < neighbor.cost) {\n        neighbor.cost = newCost;\n        minheap.push(neighbor);\n      }\n    }\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n\n    if (closestNode === finishNode) return visitedNodesInOrder;\n  }\n}\n","export function queue() {\n  this.items = [];\n}\n\nqueue.prototype = {\n  isEmpty: function () {\n    return this.items.length === 0;\n  },\n  enqueue: function (element) {\n    this.items.push(element);\n  },\n  dequeue: function () {\n    if (this.isEmpty()) return \"Underflow\";\n    return this.items.shift();\n  },\n  clear: function () {\n    this.items = [];\n  },\n};\n","import { getUnvisitedNeighbors } from \"./utils\";\nimport { queue } from \"../Datastructer/queue\";\n\nexport function greedyBFS(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  startNode.cost = 0;\n  visitedNodesInOrder.push(startNode);\n  //const unvisitedNodes = getAllNodes(grid);\n  var q = new queue();\n  q.enqueue(startNode);\n  while (!q.isEmpty()) {\n    // sortNodesAstar(unvisitedNodes, finishNode);\n    const closestNode = q.dequeue();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    const unvisitedNeighbors = getUnvisitedNeighbors(closestNode, grid);\n    for (const neighbor of unvisitedNeighbors) {\n      if (neighbor.visited) continue;\n      if (neighbor.isWall) continue;\n      neighbor.visited = true;\n      neighbor.previousNode = closestNode;\n      visitedNodesInOrder.push(neighbor);\n      q.enqueue(neighbor);\n    }\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n  }\n}\n","import { getUnvisitedNeighbors } from \"./utils\";\n\nfunction dfsHelper(node, grid, finishNode, visitedNodesInOrder) {\n  if (node === finishNode) {\n    return true;\n  }\n  node.visited = true;\n  visitedNodesInOrder.push(node);\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    if (neighbor.isWall) continue;\n    if (!neighbor.visited) {\n      neighbor.previousNode = node;\n      var pathFound = dfsHelper(\n        neighbor,\n        grid,\n        finishNode,\n        visitedNodesInOrder\n      );\n      if (pathFound) {\n        visitedNodesInOrder.push(node);\n        return true;\n      }\n    }\n  }\n  visitedNodesInOrder.push(node);\n  return false;\n}\n\nexport function dfs(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  visitedNodesInOrder.push(startNode);\n  dfsHelper(startNode, grid, finishNode, visitedNodesInOrder);\n  return visitedNodesInOrder;\n}\n","import React from \"react\";\nimport FormControl from \"@material-ui/core/FormControl\";\nimport MenuItem from \"@material-ui/core/MenuItem\";\nimport Select from \"@material-ui/core/Select\";\nimport InputLabel from \"@material-ui/core/InputLabel\";\nimport { makeStyles } from \"@material-ui/core/styles\";\nimport Button from \"@material-ui/core/Button\";\nimport Grid from \"@material-ui/core/Grid\";\nimport Paper from \"@material-ui/core/Paper\";\n\nconst useStyles = makeStyles({\n  formControl: {\n    minWidth: \"200px\",\n    margin: \"10px\",\n  },\n});\n\nexport default function Controller({\n  useAlgo,\n  handelAlgoChange,\n  handelStartBtnClick,\n  handleResetButtonClick,\n  handleClearWall,\n}) {\n  const classes = useStyles();\n  return (\n    <div>\n      <Paper elevation={0}>\n        <Grid container spacing={2} alignItems=\"center\" justify=\"center\">\n          <Grid item>\n            <FormControl id=\"algorithm_select\" className={classes.formControl}>\n              <InputLabel id=\"demo-simple-select-label\">\n                Path Finding Algorithm\n              </InputLabel>\n              <Select\n                labelId=\"demo-simple-select-label\"\n                id=\"demo-simple-select\"\n                value={useAlgo}\n                onChange={handelAlgoChange}\n              >\n                <MenuItem value={1}>Dijkstra</MenuItem>\n                <MenuItem value={2}>A Star</MenuItem>\n                <MenuItem value={3}>BFS</MenuItem>\n                <MenuItem value={4}>DFS</MenuItem>\n              </Select>\n            </FormControl>\n          </Grid>\n          <Grid item>\n            <Button\n              variant=\"contained\"\n              color=\"primary\"\n              onClick={() => handelStartBtnClick()}\n            >\n              Start{\" \"}\n              {useAlgo === 1\n                ? \" - Dijkstra\"\n                : useAlgo === 2\n                ? \" - A Star\"\n                : useAlgo === 3\n                ? \" - BFS\"\n                : useAlgo === 4\n                ? \" - DFS\"\n                : \"\"}\n            </Button>\n          </Grid>\n          <Grid item>\n            <Button\n              variant=\"contained\"\n              color=\"primary\"\n              onClick={() => handleResetButtonClick()}\n            >\n              Reset\n            </Button>\n          </Grid>\n          <Grid item>\n            <Button\n              variant=\"contained\"\n              color=\"primary\"\n              onClick={() => handleClearWall()}\n            >\n              Clear Obstacle\n            </Button>\n          </Grid>\n        </Grid>\n      </Paper>\n    </div>\n  );\n}\n","import React, { useState } from \"react\";\nimport GraphNode from \"./GraphNode\";\nimport \"./graph.css\";\nimport { dijkstra } from \"../algorithms/dijkstra\";\nimport { aStar } from \"../algorithms/aStar\";\nimport { greedyBFS } from \"../algorithms/greedyBFS\";\nimport { dfs } from \"../algorithms/dfs\";\nimport { getNodesInShortestPathOrder } from \"../algorithms/utils\";\nimport Controller from \"./Controller\";\n\nconst START_NODE_ROW = 10;\nconst START_NODE_COL = 15;\nconst FINISH_NODE_ROW = 10;\nconst FINISH_NODE_COL = 35;\n\nconst initGrid = () => {\n  const grid = [];\n  for (let row = 0; row < 20; row++) {\n    const currentRow = [];\n    for (let col = 0; col < 50; col++) {\n      currentRow.push(getNewNode(col, row));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst getNewNode = (col, row) => {\n  return {\n    col,\n    row,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    distance: Infinity,\n    cost: Infinity,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n  };\n};\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWall: true,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nexport default function Graph() {\n  const [grid, setGrid] = useState(initGrid());\n  const [mouseDown, setMouse] = useState(false);\n  const [startMove, setstartMove] = useState(false);\n  const [endMove, setEndMove] = useState(false);\n  const [startROW, setstartROW] = useState(10);\n  const [startCOL, setstartCOL] = useState(15);\n  const [endROW, setendROW] = useState(10);\n  const [endCOL, setendCOL] = useState(35);\n  const [useAlgo, setAlgo] = useState(1);\n  const [algoDone, setalgoDone] = useState(false);\n\n  const getNewGridWithStartMoved = (grid, row, col) => {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n    const newNode = {\n      ...node,\n      isStart: !node.isStart,\n    };\n    newGrid[row][col] = newNode;\n    return newGrid;\n  };\n\n  const getNewGridWithEndMoved = (grid, row, col) => {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n    const newNode = {\n      ...node,\n      isFinish: !node.isFinish,\n    };\n    newGrid[row][col] = newNode;\n    return newGrid;\n  };\n\n  const handleMouseDown = (row, col) => {\n    if (row === startROW && col === startCOL) {\n      //move start\n      setstartMove(true);\n    } else if (row === endROW && col === endCOL) {\n      //move end\n      setEndMove(true);\n    } else {\n      const newGrid = getNewGridWithWallToggled(grid, row, col);\n      setGrid(newGrid);\n      setMouse(true);\n    }\n  };\n\n  const handleMouseEnter = (row, col) => {\n    if (startMove) {\n      const newGrid = getNewGridWithStartMoved(grid, row, col);\n      setstartROW(row);\n      setstartCOL(col);\n      setGrid(newGrid);\n    } else if (endMove) {\n      const newGrid = getNewGridWithEndMoved(grid, row, col);\n      setendROW(row);\n      setendCOL(col);\n      setGrid(newGrid);\n    } else {\n      return;\n    }\n  };\n\n  const handleMouseOut = (row, col) => {\n    if (startMove) {\n      const newGrid = getNewGridWithStartMoved(grid, row, col);\n      setstartROW(row);\n      setstartCOL(col);\n      setGrid(newGrid);\n    } else if (endMove) {\n      const newGrid = getNewGridWithEndMoved(grid, row, col);\n      setendROW(row);\n      setendCOL(col);\n      setGrid(newGrid);\n    } else if (mouseDown) {\n      const newGrid = getNewGridWithWallToggled(grid, row, col);\n      setGrid(newGrid);\n    } else {\n      return;\n    }\n  };\n\n  const handleMouseUp = () => {\n    if (startMove) {\n      setstartMove(false);\n      if (algoDone) {\n        handelSPafterAlgocomplete();\n      }\n    } else if (endMove) {\n      setEndMove(false);\n      if (algoDone) {\n        handelSPafterAlgocomplete();\n      }\n    } else if (mouseDown) {\n      setMouse(false);\n    }\n  };\n\n  const handleResetButtonClick = () => {\n    setGrid(initGrid());\n    setstartROW(START_NODE_ROW);\n    setstartCOL(START_NODE_COL);\n    setendROW(FINISH_NODE_ROW);\n    setendCOL(FINISH_NODE_COL);\n    setalgoDone(false);\n    for (let i = 0; i < grid.length; i++) {\n      for (let j = 0; j < grid[0].length; j++) {\n        const node = grid[i][j];\n        if (node.row === START_NODE_ROW && node.col === START_NODE_COL) {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-start\";\n        } else if (\n          node.row === FINISH_NODE_ROW &&\n          node.col === FINISH_NODE_COL\n        ) {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-finish\";\n        } else {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node\";\n        }\n      }\n    }\n  };\n\n  const handleClearWall = () => {\n    const newGrid = grid.slice();\n    for (let i = 0; i < newGrid.length; i++) {\n      for (let j = 0; j < newGrid[0].length; j++) {\n        const node = newGrid[i][j];\n        if (node.isWall) {\n          node.isWall = false;\n        }\n      }\n    }\n    setGrid(newGrid);\n  };\n\n  const resetAllDistance = () => {\n    const newGrid = grid.slice();\n    for (let i = 0; i < newGrid.length; i++) {\n      for (let j = 0; j < newGrid[0].length; j++) {\n        const node = newGrid[i][j];\n        node.distance = Infinity;\n        node.cost = Infinity;\n        node.isVisited = false;\n      }\n    }\n    setGrid(newGrid);\n  };\n\n  const handelAlgoChange = (e) => {\n    setAlgo(e.target.value);\n  };\n\n  const resetAllClassName = () => {\n    for (let row = 0; row < 20; row++) {\n      for (let col = 0; col < 50; col++) {\n        if (\n          !(\n            document.getElementById(`node-${row}-${col}`).className ===\n              \"node node-finish\" ||\n            document.getElementById(`node-${row}-${col}`).className ===\n              \"node node-start\" ||\n            document.getElementById(`node-${row}-${col}`).className ===\n              \"node node-wall\"\n          )\n        ) {\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\n        }\n      }\n    }\n  };\n\n  const directShowVisitedNode = (\n    visitedNodesInOrder,\n    nodesInShortestPathOrder\n  ) => {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        directShowShortestPath(nodesInShortestPathOrder);\n        return;\n      }\n      const node = visitedNodesInOrder[i];\n      document.getElementById(`node-${node.row}-${node.col}`).className =\n        \"node node-visited\";\n    }\n  };\n\n  const directShowShortestPath = (nodesInShortestPathOrder) => {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      const node = nodesInShortestPathOrder[i];\n      document.getElementById(`node-${node.row}-${node.col}`).className =\n        \"node node-shortest-path\";\n    }\n  };\n\n  const handelSPafterAlgocomplete = () => {\n    const startNode = grid[startROW][startCOL];\n    const finishNode = grid[endROW][endCOL];\n    resetAllDistance();\n    resetAllClassName();\n    var visitedNodesInOrder;\n    switch (useAlgo) {\n      case 2:\n        visitedNodesInOrder = aStar(grid, startNode, finishNode);\n        break;\n      case 3:\n        visitedNodesInOrder = greedyBFS(grid, startNode, finishNode);\n        break;\n      case 4:\n        visitedNodesInOrder = dfs(grid, startNode, finishNode);\n        break;\n      default:\n        visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n    }\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    directShowVisitedNode(visitedNodesInOrder, nodesInShortestPathOrder);\n  };\n\n  const animateVisitedNode = (\n    visitedNodesInOrder,\n    nodesInShortestPathOrder\n  ) => {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-visited\";\n      }, 10 * i);\n    }\n  };\n\n  const animateShortestPath = (nodesInShortestPathOrder) => {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-shortest-path\";\n      }, 50 * i);\n    }\n  };\n\n  const handelStartBtnClick = () => {\n    const startNode = grid[startROW][startCOL];\n    const finishNode = grid[endROW][endCOL];\n    resetAllDistance();\n    var visitedNodesInOrder;\n    switch (useAlgo) {\n      case 2:\n        visitedNodesInOrder = aStar(grid, startNode, finishNode);\n        break;\n      case 3:\n        visitedNodesInOrder = greedyBFS(grid, startNode, finishNode);\n        break;\n      case 4:\n        visitedNodesInOrder = dfs(grid, startNode, finishNode);\n        break;\n      default:\n        visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n    }\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    animateVisitedNode(visitedNodesInOrder, nodesInShortestPathOrder);\n    setalgoDone(true);\n  };\n\n  return (\n    <React.Fragment>\n      <div className=\"grid\">\n        {grid.map((row, rowIdx) => {\n          return (\n            <div key={rowIdx} className=\"graphRow\">\n              {row.map((node, nodeIdx) => {\n                const { row, col, isFinish, isStart, isWall } = node;\n                return (\n                  <GraphNode\n                    key={nodeIdx}\n                    col={col}\n                    isFinish={isFinish}\n                    isStart={isStart}\n                    isWall={isWall}\n                    mouseIsPressed={mouseDown}\n                    onMouseDown={(row, col) => handleMouseDown(row, col)}\n                    onMouseEnter={(row, col) => handleMouseEnter(row, col)}\n                    onMouseUp={() => handleMouseUp()}\n                    onMouseOut={(row, col) => handleMouseOut(row, col)}\n                    row={row}\n                  ></GraphNode>\n                );\n              })}\n            </div>\n          );\n        })}\n      </div>\n      <Controller\n        useAlgo={useAlgo}\n        handelAlgoChange={handelAlgoChange}\n        handelStartBtnClick={handelStartBtnClick}\n        handleResetButtonClick={handleResetButtonClick}\n        handleClearWall={handleClearWall}\n      ></Controller>\n    </React.Fragment>\n  );\n}\n","import React from \"react\";\nimport Grid from \"@material-ui/core/Grid\";\nimport Paper from \"@material-ui/core/Paper\";\n\nexport default function Label() {\n  return (\n    <div className=\"top-label\">\n      <Paper elevation={0}>\n        <Grid container spacing={2} alignItems=\"center\" justify=\"center\">\n          <Grid item>\n            <div className=\"node node-finish\"></div>\n          </Grid>\n          <Grid item>\n            <div>Target node</div>\n          </Grid>\n          <Grid item>\n            <div className=\"node node-start\"></div>\n          </Grid>\n          <Grid item>\n            <div>Start node</div>\n          </Grid>\n          <Grid item>\n            <div className=\"node\"></div>\n          </Grid>\n          <Grid item>\n            <div>Unvisited node</div>\n          </Grid>\n          <Grid item>\n            <div className=\"node node-wall\"></div>\n          </Grid>\n          <Grid item>\n            <div>Obstacle node</div>\n          </Grid>\n          <Grid item>\n            <div className=\"node visited-1\"></div>\n            <div className=\"node visited-2\"></div>\n            <div className=\"node visited-3\"></div>\n            <div className=\"node visited-4\"></div>\n          </Grid>\n          <Grid item>\n            <div>Visited node</div>\n          </Grid>\n        </Grid>\n      </Paper>\n    </div>\n  );\n}\n","import React from \"react\";\nimport \"./App.css\";\nimport Graph from \"./components/Graph\";\nimport Label from \"./components/label\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Label></Label>\n      <Graph></Graph>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}