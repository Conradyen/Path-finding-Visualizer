{"version":3,"sources":["components/overlay.js","components/GraphNode.js","algorithms/utils.js","algorithms/dijkstra.js","Datastructer/heap.js","algorithms/aStar.js","Datastructer/queue.js","algorithms/dfs.js","components/Controller.js","components/Graph.js","algorithms/greedyBFS.js","components/label.js","App.js","serviceWorker.js","index.js"],"names":["Overlay","color","style","height","width","zIndex","opacity","backgroundColor","GraphNode","key","col","isFinish","isStart","isWall","onMouseDown","mouseIsPressed","onMouseEnter","onMouseUp","onMouseOut","row","extraClassName","id","className","sortNodes","unvisitedNodes","sort","nodeA","nodeB","distance","updateUnvisitedNeighbors","node","grid","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","previousNode","neighbors","push","length","filter","isVisited","getNodesInShortestPathOrder","finishNode","nodesInShortestPathOrder","currentNode","unshift","dijkstra","startNode","visitedNodesInOrder","nodes","getAllNodes","closestNode","shift","Infinity","minHeap","scoreFunction","this","content","aStar","cost","minheap","isEmpty","pop","newCost","Math","abs","queue","items","dfs","dfsHelper","visited","prototype","element","percolateUp","result","end","percolateDown","size","n","score","parentN","floor","parent","elemScore","child2N","child1N","swap","child1","child1Score","child2","enqueue","dequeue","clear","useStyles","makeStyles","formControl","minWidth","margin","Controller","useAlgo","handelAlgoChange","handelStartBtnClick","handleResetButtonClick","handleClearWall","classes","Paper","elevation","Grid","container","spacing","alignItems","justify","item","FormControl","InputLabel","Select","labelId","value","onChange","MenuItem","Button","variant","onClick","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","initGrid","currentRow","getNewNode","getNewGridWithWallToggled","newGrid","slice","newNode","Graph","useState","setGrid","mouseDown","setMouse","startMove","setstartMove","endMove","setEndMove","startROW","setstartROW","startCOL","setstartCOL","endROW","setendROW","endCOL","setendCOL","setAlgo","algoDone","setalgoDone","getNewGridWithStartMoved","getNewGridWithEndMoved","resetAllDistance","i","j","directShowShortestPath","document","getElementById","handelSPafterAlgocomplete","resetAllClassName","animateShortestPath","setTimeout","Fragment","DndProvider","backend","Backend","map","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseOut","e","target","q","greedyBFS","animateVisitedNode","href","icon","faGithub","Label","App","Boolean","window","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.9ad77b2b.chunk.js","sourcesContent":["import React from \"react\";\nconst Overlay = ({ color }) => {\n  return (\n    <div\n      style={{\n        height: \"25px\",\n        width: \"25px\",\n        zIndex: 1,\n        opacity: 0.8,\n        backgroundColor: color,\n      }}\n    ></div>\n  );\n};\nexport default Overlay;\n","import React from \"react\";\nimport \"./node.css\";\nimport Overlay from \"./overlay\";\n\nexport default function GraphNode({\n  key,\n  col,\n  isFinish,\n  isStart,\n  isWall,\n  mouseIsPressed,\n  onMouseDown,\n  onMouseEnter,\n  onMouseUp,\n  onMouseOut,\n  row,\n}) {\n  const extraClassName = isWall ? \"node-wall\" : \"\";\n  return (\n    <div\n      id={`node-${row}-${col}`}\n      className={`node ${extraClassName}`}\n      onMouseDown={() => onMouseDown(row, col)}\n      onMouseEnter={() => onMouseEnter(row, col)}\n      onMouseUp={() => onMouseUp()}\n      onMouseOut={() => onMouseOut(row, col)}\n    >\n      <Overlay color={isStart ? \"red\" : isFinish ? \"green\" : null} />\n    </div>\n  );\n}\n","export function sortNodes(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nexport function sortNodesAstar(unvisitedNodes, endNode) {\n  unvisitedNodes.sort(\n    (nodeA, nodeB) =>\n      nodeA.distance +\n      euclideanDistance(nodeA, endNode) -\n      (nodeB.distance + euclideanDistance(nodeB, endNode))\n  );\n}\n\nexport function NodeCompareElement(Node) {\n  return Node.distance;\n}\n\nexport function updateUnvisitedNeighbors(node, grid, distance) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\n\nexport function getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\n}\n\nexport function getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\n//calculate distance between start and end.\nexport function euclideanDistance(startNode, endNode) {\n  const col_d = Math.abs(endNode.col - startNode.col);\n  const row_d = Math.abs(endNode.row - startNode.row);\n  return col_d + row_d;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","import { sortNodes, updateUnvisitedNeighbors, getAllNodes } from \"./utils\";\n\n// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (!!unvisitedNodes.length) {\n    sortNodes(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid, 0);\n  }\n}\n","export function minHeap(scoreFunction) {\n  this.content = [];\n  this.scoreFunction = scoreFunction;\n}\n\nminHeap.prototype = {\n  isEmpty: function () {\n    return this.content.length === 0;\n  },\n  push: function (element) {\n    this.content.push(element);\n    this.percolateUp(this.content.length - 1);\n  },\n\n  pop: function () {\n    var result = this.content[0];\n    var end = this.content.pop();\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.percolateDown(0);\n    }\n    return result;\n  },\n\n  size: function () {\n    return this.content.length;\n  },\n\n  percolateUp: function (n) {\n    var element = this.content[n],\n      score = this.scoreFunction(element);\n    while (n > 0) {\n      var parentN = Math.floor((n + 1) / 2) - 1,\n        parent = this.content[parentN];\n      if (score > this.scoreFunction(parent)) break;\n      this.content[parentN] = element;\n      this.content[n] = parent;\n      n = parentN;\n    }\n  },\n\n  percolateDown: function (n) {\n    var length = this.content.length,\n      element = this.content[n],\n      elemScore = this.scoreFunction(element);\n\n    while (true) {\n      var child2N = (n + 1) * 2,\n        child1N = child2N - 1;\n      var swap = null;\n\n      if (child1N < length) {\n        var child1 = this.content[child1N],\n          child1Score = this.scoreFunction(child1);\n        if (child1Score < elemScore) swap = child1N;\n      }\n      if (child2N < length) {\n        var child2 = this.content[child2N],\n          child2Score = this.scoreFunction(child2);\n        if (child2Score < (swap == null ? elemScore : child1Score))\n          swap = child2N;\n      }\n\n      if (swap == null) break;\n      this.content[n] = this.content[swap];\n      this.content[swap] = element;\n      n = swap;\n    }\n  },\n};\n","import { getUnvisitedNeighbors } from \"./utils\";\nimport { minHeap } from \"../Datastructer/heap\";\n\nexport function aStar(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  startNode.cost = 0;\n  visitedNodesInOrder.push(startNode);\n  //const unvisitedNodes = getAllNodes(grid);\n  var minheap = new minHeap((node) => {\n    return node.cost;\n  });\n  minheap.push(startNode);\n  while (!minheap.isEmpty()) {\n    // sortNodesAstar(unvisitedNodes, finishNode);\n    const closestNode = minheap.pop();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    const unvisitedNeighbors = getUnvisitedNeighbors(closestNode, grid);\n    for (const neighbor of unvisitedNeighbors) {\n      if (closestNode.distance + 1 < neighbor.distance) {\n        neighbor.distance = closestNode.distance + 1;\n        neighbor.previousNode = closestNode;\n        visitedNodesInOrder.push(closestNode);\n      }\n      var newCost =\n        closestNode.distance +\n        Math.abs(finishNode.col - neighbor.col) +\n        Math.abs(finishNode.row - neighbor.row);\n\n      if (newCost < neighbor.cost) {\n        neighbor.cost = newCost;\n        minheap.push(neighbor);\n      }\n    }\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n\n    if (closestNode === finishNode) return visitedNodesInOrder;\n  }\n}\n","export function queue() {\n  this.items = [];\n}\n\nqueue.prototype = {\n  isEmpty: function () {\n    return this.items.length === 0;\n  },\n  enqueue: function (element) {\n    this.items.push(element);\n  },\n  dequeue: function () {\n    if (this.isEmpty()) return \"Underflow\";\n    return this.items.shift();\n  },\n  clear: function () {\n    this.items = [];\n  },\n};\n","import { getUnvisitedNeighbors } from \"./utils\";\n\nfunction dfsHelper(node, grid, finishNode, visitedNodesInOrder) {\n  if (node === finishNode) {\n    return true;\n  }\n  node.visited = true;\n  visitedNodesInOrder.push(node);\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    if (neighbor.isWall) continue;\n    if (!neighbor.visited) {\n      neighbor.previousNode = node;\n      neighbor.visited = true;\n      var pathFound = dfsHelper(\n        neighbor,\n        grid,\n        finishNode,\n        visitedNodesInOrder\n      );\n      if (pathFound) {\n        visitedNodesInOrder.push(node);\n        return true;\n      }\n    }\n  }\n  visitedNodesInOrder.push(node);\n  return false;\n}\n\nexport function dfs(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  visitedNodesInOrder.push(startNode);\n  dfsHelper(startNode, grid, finishNode, visitedNodesInOrder);\n  return visitedNodesInOrder;\n}\n","import React from \"react\";\nimport FormControl from \"@material-ui/core/FormControl\";\nimport MenuItem from \"@material-ui/core/MenuItem\";\nimport Select from \"@material-ui/core/Select\";\nimport InputLabel from \"@material-ui/core/InputLabel\";\nimport { makeStyles } from \"@material-ui/core/styles\";\nimport Button from \"@material-ui/core/Button\";\nimport Grid from \"@material-ui/core/Grid\";\nimport Paper from \"@material-ui/core/Paper\";\n\nconst useStyles = makeStyles({\n  formControl: {\n    minWidth: \"200px\",\n    margin: \"10px\",\n  },\n});\n\nexport default function Controller({\n  useAlgo,\n  handelAlgoChange,\n  handelStartBtnClick,\n  handleResetButtonClick,\n  handleClearWall,\n}) {\n  const classes = useStyles();\n  return (\n    <div>\n      <Paper elevation={0}>\n        <Grid container spacing={2} alignItems=\"center\" justify=\"center\">\n          <Grid item>\n            <FormControl id=\"algorithm_select\" className={classes.formControl}>\n              <InputLabel id=\"demo-simple-select-label\">\n                Path Finding Algorithm\n              </InputLabel>\n              <Select\n                labelId=\"demo-simple-select-label\"\n                id=\"demo-simple-select\"\n                value={useAlgo}\n                onChange={handelAlgoChange}\n              >\n                <MenuItem value={1}>Dijkstra</MenuItem>\n                <MenuItem value={2}>A Star</MenuItem>\n                <MenuItem value={3}>BFS</MenuItem>\n              </Select>\n            </FormControl>\n          </Grid>\n          <Grid item>\n            <Button\n              variant=\"contained\"\n              color=\"primary\"\n              onClick={() => handelStartBtnClick()}\n            >\n              Start{\" \"}\n              {useAlgo === 1\n                ? \" - Dijkstra\"\n                : useAlgo === 2\n                ? \" - A Star\"\n                : useAlgo === 3\n                ? \" - BFS\"\n                : useAlgo === 4\n                ? \" - DFS\"\n                : \"\"}\n            </Button>\n          </Grid>\n          <Grid item>\n            <Button\n              variant=\"contained\"\n              color=\"primary\"\n              onClick={() => handleResetButtonClick()}\n            >\n              Reset\n            </Button>\n          </Grid>\n          <Grid item>\n            <Button\n              variant=\"contained\"\n              color=\"primary\"\n              onClick={() => handleClearWall()}\n            >\n              Clear Obstacle\n            </Button>\n          </Grid>\n        </Grid>\n      </Paper>\n    </div>\n  );\n}\n","import React, { useState } from \"react\";\nimport GraphNode from \"./GraphNode\";\nimport \"./graph.css\";\nimport { DndProvider } from \"react-dnd\";\nimport Backend from \"react-dnd-html5-backend\";\nimport { dijkstra } from \"../algorithms/dijkstra\";\nimport { aStar } from \"../algorithms/aStar\";\nimport { greedyBFS } from \"../algorithms/greedyBFS\";\nimport { dfs } from \"../algorithms/dfs\";\nimport { getNodesInShortestPathOrder } from \"../algorithms/utils\";\nimport Controller from \"./Controller\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { faGithub } from \"@fortawesome/free-brands-svg-icons\";\n\nconst START_NODE_ROW = 10;\nconst START_NODE_COL = 15;\nconst FINISH_NODE_ROW = 10;\nconst FINISH_NODE_COL = 35;\n\nconst initGrid = () => {\n  const grid = [];\n  for (let row = 0; row < 20; row++) {\n    const currentRow = [];\n    for (let col = 0; col < 50; col++) {\n      currentRow.push(getNewNode(col, row));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst getNewNode = (col, row) => {\n  return {\n    col,\n    row,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    distance: Infinity,\n    cost: Infinity,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n  };\n};\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWall: true,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nexport default function Graph() {\n  const [grid, setGrid] = useState(initGrid());\n  const [mouseDown, setMouse] = useState(false);\n  const [startMove, setstartMove] = useState(false);\n  const [endMove, setEndMove] = useState(false);\n  const [startROW, setstartROW] = useState(10);\n  const [startCOL, setstartCOL] = useState(15);\n  const [endROW, setendROW] = useState(10);\n  const [endCOL, setendCOL] = useState(35);\n  const [useAlgo, setAlgo] = useState(1);\n  const [algoDone, setalgoDone] = useState(false);\n\n  const getNewGridWithStartMoved = (grid, row, col) => {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n    const newNode = {\n      ...node,\n      isStart: !node.isStart,\n    };\n    newGrid[row][col] = newNode;\n    return newGrid;\n  };\n\n  const getNewGridWithEndMoved = (grid, row, col) => {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n    const newNode = {\n      ...node,\n      isFinish: !node.isFinish,\n    };\n    newGrid[row][col] = newNode;\n    return newGrid;\n  };\n\n  const handleMouseDown = (row, col) => {\n    if (row === startROW && col === startCOL) {\n      //move start\n      setstartMove(true);\n    } else if (row === endROW && col === endCOL) {\n      //move end\n      setEndMove(true);\n    } else {\n      const newGrid = getNewGridWithWallToggled(grid, row, col);\n      setGrid(newGrid);\n      setMouse(true);\n    }\n  };\n\n  const handleMouseEnter = (row, col) => {\n    if (startMove) {\n      const newGrid = getNewGridWithStartMoved(grid, row, col);\n      setstartROW(row);\n      setstartCOL(col);\n      setGrid(newGrid);\n    } else if (endMove) {\n      const newGrid = getNewGridWithEndMoved(grid, row, col);\n      setendROW(row);\n      setendCOL(col);\n      setGrid(newGrid);\n    } else {\n      return;\n    }\n  };\n\n  const handleMouseOut = (row, col) => {\n    if (startMove) {\n      const newGrid = getNewGridWithStartMoved(grid, row, col);\n      setstartROW(row);\n      setstartCOL(col);\n      setGrid(newGrid);\n    } else if (endMove) {\n      const newGrid = getNewGridWithEndMoved(grid, row, col);\n      setendROW(row);\n      setendCOL(col);\n      setGrid(newGrid);\n    } else if (mouseDown) {\n      const newGrid = getNewGridWithWallToggled(grid, row, col);\n      setGrid(newGrid);\n    } else {\n      return;\n    }\n  };\n\n  const handleMouseUp = () => {\n    if (startMove) {\n      setstartMove(false);\n      if (algoDone) {\n        handelSPafterAlgocomplete();\n      }\n    } else if (endMove) {\n      setEndMove(false);\n      if (algoDone) {\n        handelSPafterAlgocomplete();\n      }\n    } else if (mouseDown) {\n      setMouse(false);\n    }\n  };\n\n  const handleResetButtonClick = () => {\n    setGrid(initGrid());\n    setstartROW(START_NODE_ROW);\n    setstartCOL(START_NODE_COL);\n    setendROW(FINISH_NODE_ROW);\n    setendCOL(FINISH_NODE_COL);\n    setalgoDone(false);\n    for (let i = 0; i < grid.length; i++) {\n      for (let j = 0; j < grid[0].length; j++) {\n        const node = grid[i][j];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node\";\n      }\n    }\n  };\n\n  const handleClearWall = () => {\n    const newGrid = grid.slice();\n    for (let i = 0; i < newGrid.length; i++) {\n      for (let j = 0; j < newGrid[0].length; j++) {\n        const node = newGrid[i][j];\n        if (node.isWall) {\n          node.isWall = false;\n        }\n      }\n    }\n    setGrid(newGrid);\n  };\n\n  const resetAllDistance = () => {\n    const newGrid = grid.slice();\n    for (let i = 0; i < newGrid.length; i++) {\n      for (let j = 0; j < newGrid[0].length; j++) {\n        const node = newGrid[i][j];\n        node.distance = Infinity;\n        node.cost = Infinity;\n        node.isVisited = false;\n        node.previousNode = null;\n        newGrid[i][j] = node;\n      }\n    }\n    setGrid(newGrid);\n  };\n\n  const handelAlgoChange = (e) => {\n    setAlgo(e.target.value);\n  };\n\n  const resetAllClassName = () => {\n    for (let row = 0; row < 20; row++) {\n      for (let col = 0; col < 50; col++) {\n        if (\n          !(\n            document.getElementById(`node-${row}-${col}`).className ===\n              \"node node-finish\" ||\n            document.getElementById(`node-${row}-${col}`).className ===\n              \"node node-start\" ||\n            document.getElementById(`node-${row}-${col}`).className ===\n              \"node node-wall\"\n          )\n        ) {\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\n        }\n      }\n    }\n    // document.getElementById(`node-${startROW}-${startCOL}`).className =\n    //   \"node node-start\";\n    // document.getElementById(`node-${endROW}-${endCOL}`).className =\n    //   \"node node-finish\";\n  };\n\n  const directShowVisitedNode = (\n    visitedNodesInOrder,\n    nodesInShortestPathOrder\n  ) => {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        directShowShortestPath(nodesInShortestPathOrder);\n        return;\n      }\n      const node = visitedNodesInOrder[i];\n      document.getElementById(`node-${node.row}-${node.col}`).className =\n        \"node node-visited\";\n    }\n  };\n\n  const directShowShortestPath = (nodesInShortestPathOrder) => {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      const node = nodesInShortestPathOrder[i];\n      document.getElementById(`node-${node.row}-${node.col}`).className =\n        \"node node-shortest-path\";\n    }\n  };\n\n  const handelSPafterAlgocomplete = () => {\n    resetAllDistance();\n    resetAllClassName();\n    const startNode = grid[startROW][startCOL];\n    const finishNode = grid[endROW][endCOL];\n\n    var visitedNodesInOrder;\n    visitedNodesInOrder = aStar(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    directShowShortestPath(nodesInShortestPathOrder);\n  };\n\n  const animateVisitedNode = (\n    visitedNodesInOrder,\n    nodesInShortestPathOrder\n  ) => {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      if (visitedNodesInOrder[i] === grid[startROW][startCOL]) continue;\n      if (visitedNodesInOrder[i] === grid[endROW][endCOL]) continue;\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-visited\";\n      }, 10 * i);\n    }\n  };\n\n  const animateShortestPath = (nodesInShortestPathOrder) => {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      if (nodesInShortestPathOrder[i] === grid[startROW][startCOL]) continue;\n      if (nodesInShortestPathOrder[i] === grid[endROW][endCOL]) continue;\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-shortest-path\";\n      }, 50 * i);\n    }\n  };\n\n  const handelStartBtnClick = () => {\n    const startNode = grid[startROW][startCOL];\n    const finishNode = grid[endROW][endCOL];\n    resetAllDistance();\n    var visitedNodesInOrder;\n    switch (useAlgo) {\n      case 2:\n        visitedNodesInOrder = aStar(grid, startNode, finishNode);\n        break;\n      case 3:\n        visitedNodesInOrder = greedyBFS(grid, startNode, finishNode);\n        break;\n      case 4:\n        visitedNodesInOrder = dfs(grid, startNode, finishNode);\n        break;\n      default:\n        visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n    }\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    animateVisitedNode(visitedNodesInOrder, nodesInShortestPathOrder);\n    setalgoDone(true);\n  };\n\n  return (\n    <React.Fragment>\n      <DndProvider backend={Backend}>\n        <div className=\"grid\">\n          {grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx} className=\"graphRow\">\n                {row.map((node, nodeIdx) => {\n                  const { row, col, isFinish, isStart, isWall } = node;\n                  return (\n                    <React.Fragment>\n                      <GraphNode\n                        key={nodeIdx}\n                        col={col}\n                        isFinish={isFinish}\n                        isStart={isStart}\n                        isWall={isWall}\n                        mouseIsPressed={mouseDown}\n                        onMouseDown={(row, col) => handleMouseDown(row, col)}\n                        onMouseEnter={(row, col) => handleMouseEnter(row, col)}\n                        onMouseUp={() => handleMouseUp()}\n                        onMouseOut={(row, col) => handleMouseOut(row, col)}\n                        row={row}\n                      ></GraphNode>\n                    </React.Fragment>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n      </DndProvider>\n      <Controller\n        useAlgo={useAlgo}\n        handelAlgoChange={handelAlgoChange}\n        handelStartBtnClick={handelStartBtnClick}\n        handleResetButtonClick={handleResetButtonClick}\n        handleClearWall={handleClearWall}\n      ></Controller>\n      <a href=\"https://github.com/Conradyen/Path-finding-Visualizer\">\n        <FontAwesomeIcon icon={faGithub} size=\"3x\" color=\"#7a7979\" />\n      </a>\n    </React.Fragment>\n  );\n}\n","import { getUnvisitedNeighbors } from \"./utils\";\nimport { queue } from \"../Datastructer/queue\";\n\nexport function greedyBFS(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  startNode.cost = 0;\n  visitedNodesInOrder.push(startNode);\n  //const unvisitedNodes = getAllNodes(grid);\n  var q = new queue();\n  q.enqueue(startNode);\n  while (!q.isEmpty()) {\n    // sortNodesAstar(unvisitedNodes, finishNode);\n    const closestNode = q.dequeue();\n    closestNode.isVisited = true;\n    if (closestNode.isWall) continue;\n    const unvisitedNeighbors = getUnvisitedNeighbors(closestNode, grid);\n    for (const neighbor of unvisitedNeighbors) {\n      if (neighbor.visited) continue;\n      if (neighbor.isWall) continue;\n      neighbor.visited = true;\n      neighbor.previousNode = closestNode;\n      visitedNodesInOrder.push(neighbor);\n      q.enqueue(neighbor);\n    }\n\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    visitedNodesInOrder.push(closestNode);\n  }\n}\n","import React from \"react\";\nimport Grid from \"@material-ui/core/Grid\";\nimport Paper from \"@material-ui/core/Paper\";\n\nexport default function Label() {\n  return (\n    <div className=\"top-label\">\n      <Paper elevation={0}>\n        <Grid container spacing={2} alignItems=\"center\" justify=\"center\">\n          <Grid item>\n            <div className=\"node node-finish\"></div>\n          </Grid>\n          <Grid item>\n            <div>Target node</div>\n          </Grid>\n          <Grid item>\n            <div className=\"node node-start\"></div>\n          </Grid>\n          <Grid item>\n            <div>Start node</div>\n          </Grid>\n          <Grid item>\n            <div className=\"node\"></div>\n          </Grid>\n          <Grid item>\n            <div>Unvisited node</div>\n          </Grid>\n          <Grid item>\n            <div className=\"node node-wall\"></div>\n          </Grid>\n          <Grid item>\n            <div>Obstacle node</div>\n          </Grid>\n          <Grid item>\n            <div className=\"node visited-3\"></div>\n          </Grid>\n          <Grid item>\n            <div>Path</div>\n          </Grid>\n          <Grid item>\n            <div className=\"node visited-1\"></div>\n            <div className=\"node visited-2\"></div>\n            <div className=\"node visited-4\"></div>\n          </Grid>\n          <Grid item>\n            <div>Visited node</div>\n          </Grid>\n        </Grid>\n      </Paper>\n    </div>\n  );\n}\n","import React from \"react\";\nimport \"./App.css\";\nimport Graph from \"./components/Graph\";\nimport Label from \"./components/label\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Label></Label>\n      <Graph></Graph>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}