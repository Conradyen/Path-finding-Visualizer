{"version":3,"sources":["components/GraphNode.js","algorithms/utils.js","algorithms/dijkstra.js","Datastructer/heap.js","algorithms/aStar.js","Datastructer/queue.js","algorithms/greedyBFS.js","algorithms/dfs.js","components/Controller.js","components/Graph.js","components/label.js","App.js","serviceWorker.js","index.js"],"names":["GraphNode","key","col","isFinish","isStart","isWall","onMouseDown","mouseIsPressed","onMouseEnter","onMouseUp","onMouseOut","row","extraClassName","id","className","sortNodes","unvisitedNodes","sort","nodeA","nodeB","distance","updateUnvisitedNeighbors","node","grid","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","previousNode","neighbors","push","length","filter","isVisited","getNodesInShortestPathOrder","finishNode","nodesInShortestPathOrder","currentNode","unshift","dijkstra","startNode","visitedNodesInOrder","nodes","getAllNodes","closestNode","shift","Infinity","minHeap","scoreFunction","this","content","aStar","cost","minheap","isEmpty","pop","newCost","Math","abs","queue","items","greedyBFS","q","enqueue","dequeue","visited","dfs","dfsHelper","prototype","element","percolateUp","result","end","percolateDown","size","n","score","parentN","floor","parent","elemScore","child2N","child1N","swap","child1","child1Score","child2","clear","useStyles","makeStyles","formControl","minWidth","margin","Controller","useAlgo","handelAlgoChange","handelStartBtnClick","handleResetButtonClick","classes","Paper","elevation","Grid","container","spacing","alignItems","justify","item","FormControl","InputLabel","Select","labelId","value","onChange","MenuItem","Button","variant","color","onClick","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","initGrid","currentRow","getNewNode","getNewGridWithWallToggled","newGrid","slice","newNode","Graph","useState","setGrid","mouseDown","setMouse","startMove","setstartMove","endMove","setEndMove","startROW","setstartROW","startCOL","setstartCOL","endROW","setendROW","endCOL","setendCOL","setAlgo","setalgoDone","getNewGridWithStartMoved","getNewGridWithEndMoved","i","j","document","getElementById","animateShortestPath","setTimeout","Fragment","map","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseOut","e","target","animateVisitedNode","Label","App","Boolean","window","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.a13265ad.chunk.js","sourcesContent":["import React from \"react\";\nimport \"./node.css\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { faPlay, faMapMarkerAlt } from \"@fortawesome/free-solid-svg-icons\";\n\nexport default function GraphNode({\n  key,\n  col,\n  isFinish,\n  isStart,\n  isWall,\n  mouseIsPressed,\n  onMouseDown,\n  onMouseEnter,\n  onMouseUp,\n  onMouseOut,\n  row,\n}) {\n  const extraClassName = isFinish\n    ? \"node-finish\"\n    : isStart\n    ? \"node-start\"\n    : isWall\n    ? \"node-wall\"\n    : \"\";\n  return (\n    <div\n      id={`node-${row}-${col}`}\n      className={`node ${extraClassName}`}\n      onMouseDown={() => onMouseDown(row, col)}\n      onMouseEnter={() => onMouseEnter(row, col)}\n      onMouseUp={() => onMouseUp()}\n      onMouseOut={() => onMouseOut(row, col)}\n    ></div>\n  );\n}\n","export function sortNodes(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nexport function sortNodesAstar(unvisitedNodes, endNode) {\n  unvisitedNodes.sort(\n    (nodeA, nodeB) =>\n      nodeA.distance +\n      euclideanDistance(nodeA, endNode) -\n      (nodeB.distance + euclideanDistance(nodeB, endNode))\n  );\n}\n\nexport function NodeCompareElement(Node) {\n  return Node.distance;\n}\n\nexport function updateUnvisitedNeighbors(node, grid, distance) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\n\nexport function getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\n}\n\nexport function getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\n//calculate distance between start and end.\nexport function euclideanDistance(startNode, endNode) {\n  const col_d = Math.abs(endNode.col - startNode.col);\n  const row_d = Math.abs(endNode.row - startNode.row);\n  return col_d + row_d;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","import { sortNodes, updateUnvisitedNeighbors, getAllNodes } from \"./utils\";\n\n// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (!!unvisitedNodes.length) {\n    sortNodes(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid, 0);\n  }\n}\n","export function minHeap(scoreFunction) {\n  this.content = [];\n  this.scoreFunction = scoreFunction;\n}\n\nminHeap.prototype = {\n  isEmpty: function () {\n    return this.content.length === 0;\n  },\n  push: function (element) {\n    // Add the new element to the end of the array.\n    this.content.push(element);\n    // Allow it to bubble up.\n    this.percolateUp(this.content.length - 1);\n  },\n\n  pop: function () {\n    // Store the first element so we can return it later.\n    var result = this.content[0];\n    // Get the element at the end of the array.\n    var end = this.content.pop();\n    // If there are any elements left, put the end element at the\n    // start, and let it sink down.\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.percolateDown(0);\n    }\n    return result;\n  },\n\n  size: function () {\n    return this.content.length;\n  },\n\n  percolateUp: function (n) {\n    // Fetch the element that has to be moved.\n    var element = this.content[n],\n      score = this.scoreFunction(element);\n    // When at 0, an element can not go up any further.\n    while (n > 0) {\n      // Compute the parent element's index, and fetch it.\n      var parentN = Math.floor((n + 1) / 2) - 1,\n        parent = this.content[parentN];\n      // If the parent has a lesser score, things are in order and we\n      // are done.\n      if (score > this.scoreFunction(parent)) break;\n\n      // Otherwise, swap the parent with the current element and\n      // continue.\n      this.content[parentN] = element;\n      this.content[n] = parent;\n      n = parentN;\n    }\n  },\n\n  percolateDown: function (n) {\n    // Look up the target element and its score.\n    var length = this.content.length,\n      element = this.content[n],\n      elemScore = this.scoreFunction(element);\n\n    while (true) {\n      // Compute the indices of the child elements.\n      var child2N = (n + 1) * 2,\n        child1N = child2N - 1;\n      // This is used to store the new position of the element,\n      // if any.\n      var swap = null;\n      // If the first child exists (is inside the array)...\n      if (child1N < length) {\n        // Look it up and compute its score.\n        var child1 = this.content[child1N],\n          child1Score = this.scoreFunction(child1);\n        // If the score is less than our element's, we need to swap.\n        if (child1Score < elemScore) swap = child1N;\n      }\n      // Do the same checks for the other child.\n      if (child2N < length) {\n        var child2 = this.content[child2N],\n          child2Score = this.scoreFunction(child2);\n        if (child2Score < (swap == null ? elemScore : child1Score))\n          swap = child2N;\n      }\n\n      // No need to swap further, we are done.\n      if (swap == null) break;\n\n      // Otherwise, swap and continue.\n      this.content[n] = this.content[swap];\n      this.content[swap] = element;\n      n = swap;\n    }\n  },\n};\n","import { getUnvisitedNeighbors } from \"./utils\";\nimport { minHeap } from \"../Datastructer/heap\";\n\nexport function aStar(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  startNode.cost = 0;\n  visitedNodesInOrder.push(startNode);\n  //const unvisitedNodes = getAllNodes(grid);\n  var minheap = new minHeap((node) => {\n    return node.cost;\n  });\n  minheap.push(startNode);\n  while (!minheap.isEmpty()) {\n    // sortNodesAstar(unvisitedNodes, finishNode);\n    const closestNode = minheap.pop();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    const unvisitedNeighbors = getUnvisitedNeighbors(closestNode, grid);\n    for (const neighbor of unvisitedNeighbors) {\n      if (closestNode.distance + 1 < neighbor.distance) {\n        neighbor.distance = closestNode.distance + 1;\n        neighbor.previousNode = closestNode;\n        visitedNodesInOrder.push(closestNode);\n      }\n      var newCost =\n        closestNode.distance +\n        Math.abs(finishNode.col - neighbor.col) +\n        Math.abs(finishNode.row - neighbor.row);\n\n      if (newCost < neighbor.cost) {\n        neighbor.cost = newCost;\n        minheap.push(neighbor);\n      }\n    }\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n\n    if (closestNode === finishNode) return visitedNodesInOrder;\n  }\n}\n","export function queue() {\n  this.items = [];\n}\n\nqueue.prototype = {\n  isEmpty: function () {\n    return this.items.length === 0;\n  },\n  enqueue: function (element) {\n    this.items.push(element);\n  },\n  dequeue: function () {\n    if (this.isEmpty()) return \"Underflow\";\n    return this.items.shift();\n  },\n  clear: function () {\n    this.items = [];\n  },\n};\n","import { getUnvisitedNeighbors } from \"./utils\";\nimport { queue } from \"../Datastructer/queue\";\n\nexport function greedyBFS(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  startNode.cost = 0;\n  visitedNodesInOrder.push(startNode);\n  //const unvisitedNodes = getAllNodes(grid);\n  var q = new queue();\n  q.enqueue(startNode);\n  while (!q.isEmpty()) {\n    // sortNodesAstar(unvisitedNodes, finishNode);\n    const closestNode = q.dequeue();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    const unvisitedNeighbors = getUnvisitedNeighbors(closestNode, grid);\n    for (const neighbor of unvisitedNeighbors) {\n      if (neighbor.visited) continue;\n      if (neighbor.isWall) continue;\n      neighbor.visited = true;\n      neighbor.previousNode = closestNode;\n      visitedNodesInOrder.push(neighbor);\n      q.enqueue(neighbor);\n    }\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n  }\n}\n","import { getUnvisitedNeighbors } from \"./utils\";\n\nfunction dfsHelper(node, grid, finishNode, visitedNodesInOrder) {\n  if (node === finishNode) {\n    return true;\n  }\n  node.visited = true;\n  visitedNodesInOrder.push(node);\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    if (neighbor.isWall) continue;\n    if (!neighbor.visited) {\n      neighbor.previousNode = node;\n      var pathFound = dfsHelper(\n        neighbor,\n        grid,\n        finishNode,\n        visitedNodesInOrder\n      );\n      if (pathFound) {\n        visitedNodesInOrder.push(node);\n        return true;\n      }\n    }\n  }\n  visitedNodesInOrder.push(node);\n  return false;\n}\n\nexport function dfs(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  visitedNodesInOrder.push(startNode);\n  dfsHelper(startNode, grid, finishNode, visitedNodesInOrder);\n  return visitedNodesInOrder;\n}\n","import React from \"react\";\nimport FormControl from \"@material-ui/core/FormControl\";\nimport MenuItem from \"@material-ui/core/MenuItem\";\nimport Select from \"@material-ui/core/Select\";\nimport InputLabel from \"@material-ui/core/InputLabel\";\nimport { makeStyles } from \"@material-ui/core/styles\";\nimport Button from \"@material-ui/core/Button\";\nimport Grid from \"@material-ui/core/Grid\";\nimport Paper from \"@material-ui/core/Paper\";\n\nconst useStyles = makeStyles({\n  formControl: {\n    minWidth: \"200px\",\n    margin: \"10px\",\n  },\n});\n\nexport default function Controller({\n  useAlgo,\n  handelAlgoChange,\n  handelStartBtnClick,\n  handleResetButtonClick,\n}) {\n  const classes = useStyles();\n  return (\n    <div>\n      <Paper elevation={0}>\n        <Grid container spacing={2} alignItems=\"center\" justify=\"center\">\n          <Grid item>\n            <FormControl id=\"algorithm_select\" className={classes.formControl}>\n              <InputLabel id=\"demo-simple-select-label\">\n                Path Finding Algorithm\n              </InputLabel>\n              <Select\n                labelId=\"demo-simple-select-label\"\n                id=\"demo-simple-select\"\n                value={useAlgo}\n                onChange={handelAlgoChange}\n              >\n                <MenuItem value={1}>Dijkstra</MenuItem>\n                <MenuItem value={2}>A Star</MenuItem>\n                <MenuItem value={3}>BFS</MenuItem>\n                <MenuItem value={4}>DFS</MenuItem>\n              </Select>\n            </FormControl>\n          </Grid>\n          <Grid item>\n            <Button\n              variant=\"contained\"\n              color=\"primary\"\n              onClick={() => handelStartBtnClick()}\n            >\n              Start{\" \"}\n              {useAlgo === 1\n                ? \" - Dijkstra\"\n                : useAlgo === 2\n                ? \" - A Star\"\n                : useAlgo === 3\n                ? \" - BFS\"\n                : useAlgo === 4\n                ? \" - DFS\"\n                : \"\"}\n            </Button>\n          </Grid>\n          <Grid item>\n            <Button\n              variant=\"contained\"\n              color=\"primary\"\n              onClick={() => handleResetButtonClick()}\n            >\n              Reset\n            </Button>\n          </Grid>\n        </Grid>\n      </Paper>\n    </div>\n  );\n}\n","import React, { useState } from \"react\";\nimport GraphNode from \"./GraphNode\";\nimport \"./graph.css\";\nimport { dijkstra } from \"../algorithms/dijkstra\";\nimport { aStar } from \"../algorithms/aStar\";\nimport { greedyBFS } from \"../algorithms/greedyBFS\";\nimport { dfs } from \"../algorithms/dfs\";\nimport { getNodesInShortestPathOrder } from \"../algorithms/utils\";\nimport Controller from \"./Controller\";\n\nconst START_NODE_ROW = 10;\nconst START_NODE_COL = 15;\nconst FINISH_NODE_ROW = 10;\nconst FINISH_NODE_COL = 35;\n\nconst initGrid = () => {\n  const grid = [];\n  for (let row = 0; row < 20; row++) {\n    const currentRow = [];\n    for (let col = 0; col < 50; col++) {\n      currentRow.push(getNewNode(col, row));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst getNewNode = (col, row) => {\n  return {\n    col,\n    row,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    distance: Infinity,\n    cost: Infinity,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n  };\n};\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWall: true,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nexport default function Graph() {\n  const [grid, setGrid] = useState(initGrid());\n  const [mouseDown, setMouse] = useState(false);\n  const [startMove, setstartMove] = useState(false);\n  const [endMove, setEndMove] = useState(false);\n  const [startROW, setstartROW] = useState(10);\n  const [startCOL, setstartCOL] = useState(15);\n  const [endROW, setendROW] = useState(10);\n  const [endCOL, setendCOL] = useState(35);\n  const [useAlgo, setAlgo] = useState(1);\n  const [algoDone, setalgoDone] = useState(false);\n\n  const getNewGridWithStartMoved = (grid, row, col) => {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n    const newNode = {\n      ...node,\n      isStart: !node.isStart,\n    };\n    newGrid[row][col] = newNode;\n    return newGrid;\n  };\n\n  const getNewGridWithEndMoved = (grid, row, col) => {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n    const newNode = {\n      ...node,\n      isFinish: !node.isFinish,\n    };\n    newGrid[row][col] = newNode;\n    return newGrid;\n  };\n\n  const handleMouseDown = (row, col) => {\n    if (row === startROW && col === startCOL) {\n      //move start\n      setstartMove(true);\n    } else if (row === endROW && col === endCOL) {\n      //move end\n      setEndMove(true);\n    } else {\n      const newGrid = getNewGridWithWallToggled(grid, row, col);\n      setGrid(newGrid);\n      setMouse(true);\n    }\n  };\n\n  const handleMouseEnter = (row, col) => {\n    if (startMove) {\n      const newGrid = getNewGridWithStartMoved(grid, row, col);\n      setstartROW(row);\n      setstartCOL(col);\n      setGrid(newGrid);\n    } else if (endMove) {\n      const newGrid = getNewGridWithEndMoved(grid, row, col);\n      setendROW(row);\n      setendCOL(col);\n      setGrid(newGrid);\n    } else {\n      return;\n    }\n  };\n\n  const handleMouseOut = (row, col) => {\n    if (startMove) {\n      const newGrid = getNewGridWithStartMoved(grid, row, col);\n      setstartROW(row);\n      setstartCOL(col);\n      setGrid(newGrid);\n    } else if (endMove) {\n      const newGrid = getNewGridWithEndMoved(grid, row, col);\n      setendROW(row);\n      setendCOL(col);\n      setGrid(newGrid);\n    } else if (mouseDown) {\n      const newGrid = getNewGridWithWallToggled(grid, row, col);\n      setGrid(newGrid);\n    } else {\n      return;\n    }\n  };\n\n  const handleMouseUp = () => {\n    if (startMove) {\n      setstartMove(false);\n      // if (algoDone) {\n      //   handelSPafterAlgocomplete();\n      // }\n    } else if (endMove) {\n      setEndMove(false);\n      // if (algoDone) {\n      //   handelSPafterAlgocomplete();\n      // }\n    } else if (mouseDown) {\n      setMouse(false);\n    }\n  };\n\n  const handleResetButtonClick = () => {\n    setGrid(initGrid());\n    setstartROW(START_NODE_ROW);\n    setstartCOL(START_NODE_COL);\n    setendROW(FINISH_NODE_ROW);\n    setendCOL(FINISH_NODE_COL);\n    for (let i = 0; i < grid.length; i++) {\n      for (let j = 0; j < grid[0].length; j++) {\n        const node = grid[i][j];\n        if (node.row === START_NODE_ROW && node.col === START_NODE_COL) {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-start\";\n        } else if (\n          node.row === FINISH_NODE_ROW &&\n          node.col === FINISH_NODE_COL\n        ) {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-finish\";\n        } else {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node\";\n        }\n      }\n    }\n  };\n\n  const handelAlgoChange = (e) => {\n    setAlgo(e.target.value);\n  };\n\n  const directShowVisitedNode = (\n    visitedNodesInOrder,\n    nodesInShortestPathOrder\n  ) => {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        directShowShortestPath(nodesInShortestPathOrder);\n        return;\n      }\n      const node = visitedNodesInOrder[i];\n      document.getElementById(`node-${node.row}-${node.col}`).className =\n        \"node node-visited\";\n    }\n  };\n\n  const directShowShortestPath = (nodesInShortestPathOrder) => {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      const node = nodesInShortestPathOrder[i];\n      document.getElementById(`node-${node.row}-${node.col}`).className =\n        \"node node-shortest-path\";\n    }\n  };\n\n  const handelSPafterAlgocomplete = () => {\n    const startNode = grid[startROW][startCOL];\n    const finishNode = grid[endROW][endCOL];\n    handleResetButtonClick();\n    var visitedNodesInOrder;\n    switch (useAlgo) {\n      case 2:\n        visitedNodesInOrder = aStar(grid, startNode, finishNode);\n        break;\n      case 3:\n        visitedNodesInOrder = greedyBFS(grid, startNode, finishNode);\n        break;\n      case 4:\n        visitedNodesInOrder = dfs(grid, startNode, finishNode);\n        break;\n      default:\n        visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n    }\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    directShowVisitedNode(visitedNodesInOrder, nodesInShortestPathOrder);\n  };\n\n  const animateVisitedNode = (\n    visitedNodesInOrder,\n    nodesInShortestPathOrder\n  ) => {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-visited\";\n      }, 10 * i);\n    }\n  };\n\n  const animateShortestPath = (nodesInShortestPathOrder) => {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-shortest-path\";\n      }, 50 * i);\n    }\n  };\n\n  const handelStartBtnClick = () => {\n    const startNode = grid[startROW][startCOL];\n    const finishNode = grid[endROW][endCOL];\n    var visitedNodesInOrder;\n    switch (useAlgo) {\n      case 2:\n        visitedNodesInOrder = aStar(grid, startNode, finishNode);\n        break;\n      case 3:\n        visitedNodesInOrder = greedyBFS(grid, startNode, finishNode);\n        break;\n      case 4:\n        visitedNodesInOrder = dfs(grid, startNode, finishNode);\n        break;\n      default:\n        visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n    }\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    animateVisitedNode(visitedNodesInOrder, nodesInShortestPathOrder);\n    setalgoDone(true);\n  };\n\n  return (\n    <React.Fragment>\n      <div className=\"grid\">\n        {grid.map((row, rowIdx) => {\n          return (\n            <div key={rowIdx} className=\"graphRow\">\n              {row.map((node, nodeIdx) => {\n                const { row, col, isFinish, isStart, isWall } = node;\n                return (\n                  <GraphNode\n                    key={nodeIdx}\n                    col={col}\n                    isFinish={isFinish}\n                    isStart={isStart}\n                    isWall={isWall}\n                    mouseIsPressed={mouseDown}\n                    onMouseDown={(row, col) => handleMouseDown(row, col)}\n                    onMouseEnter={(row, col) => handleMouseEnter(row, col)}\n                    onMouseUp={() => handleMouseUp()}\n                    onMouseOut={(row, col) => handleMouseOut(row, col)}\n                    row={row}\n                  ></GraphNode>\n                );\n              })}\n            </div>\n          );\n        })}\n      </div>\n      <Controller\n        useAlgo={useAlgo}\n        handelAlgoChange={handelAlgoChange}\n        handelStartBtnClick={handelStartBtnClick}\n        handleResetButtonClick={handleResetButtonClick}\n      ></Controller>\n    </React.Fragment>\n  );\n}\n","import React from \"react\";\nimport Grid from \"@material-ui/core/Grid\";\nimport Paper from \"@material-ui/core/Paper\";\n\nexport default function Label() {\n  return (\n    <div>\n      <Paper elevation={0}>\n        <Grid container spacing={2} alignItems=\"center\" justify=\"center\">\n          <Grid item>\n            <div className=\"node node-finish\"></div>\n          </Grid>\n          <Grid item>\n            <div>Target node</div>\n          </Grid>\n          <Grid item>\n            <div className=\"node node-start\"></div>\n          </Grid>\n          <Grid item>\n            <div>Start node</div>\n          </Grid>\n          <Grid item>\n            <div className=\"node\"></div>\n          </Grid>\n          <Grid item>\n            <div>Unvisited node</div>\n          </Grid>\n          <Grid item>\n            <div className=\"node node-wall\"></div>\n          </Grid>\n          <Grid item>\n            <div>Obstacle node</div>\n          </Grid>\n          <Grid item>\n            <div className=\"node visited-1\"></div>\n            <div className=\"node visited-2\"></div>\n            <div className=\"node visited-3\"></div>\n            <div className=\"node visited-4\"></div>\n          </Grid>\n          <Grid item>\n            <div>Visited node</div>\n          </Grid>\n        </Grid>\n      </Paper>\n    </div>\n  );\n}\n","import React from \"react\";\nimport \"./App.css\";\nimport Graph from \"./components/Graph\";\nimport Label from \"./components/label\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Graph></Graph>\n      <Label></Label>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}